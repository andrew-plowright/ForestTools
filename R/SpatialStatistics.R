#' Spatial statistics
#'
#' Summarization tool for calculating tree counts and statistics within various spatial units.
#'
#' Input trees can either be point locations (\link[sp:SpatialPoints]{SpatialPointsDataFrame})
#' or crown outlines (\link[sp:SpatialPolygons]{SpatialPolygonsDataFrame}). If crown outlines (or other polygons)
#' are inputted, they will be partitioned between spatial units according to their geographic centroids.
#'
#' In addition to tree counts, statistics for the trees' attributes can also be
#' generated. These attributes should be defined within the \code{@@data} slot of the \code{input}. Only
#' numeric variables are accepted.
#'
#' By default, the statistics generated for each attribute will be its mean, median, standard deviation,
#' minimum and maximum. However, custom functions can also be used with the \code{statFuns} argument.
#' This should be a named list of functions, wherein each list element is given a name to represent the
#' statistic computed by the function.
#'
#' For example: \code{list(qunt98 = function(x, ...) quantile(x, c(.98), na.rm = TRUE))}
#'
#' Furthermore, custom functions should:
#' \itemize{
#'   \item Be able to accept numeric vectors.
#'   \item Be able to handle NA values.
#'   \item Have an ellipsis (three dots) in their arguments: \code{function(x, ...)}
#'   \item Return a single numeric value.
#' }
#'
#' @param trees \link[sp:SpatialPoints]{SpatialPointsDataFrame} or \link[sp:SpatialPolygons]{SpatialPolygonsDataFrame}. The locations of a
#' set of trees, typically detected from a canopy height model using \code{\link{vwf}}.
#' Tree attributes, such as height or crown size, should be stored within this object's \code{@@data} slot.
#' Tree crowns delineated using \code{\link{SegmentCrowns}} can also be used.
#' @param areas \link[sp:SpatialPolygons]{SpatialPolygonsDataFrame}. An optional set of polygons corresponding to areas of
#' interest. Tree counts and statistics will be returned for each area.
#' @param grid RasterLayer (see \link[raster]{raster}) or numeric. An alternative to the \code{areas} argument.
#' Using \code{grid} will compute tree counts and statistics within the cells of a spatial grid.
#' Grid size and placement can be defined by inputting a \link[raster]{raster} object.
#' A single numeric value can also be used, in which case the function will generate a grid with a
#' cell size equal to this value.
#' @param variables character. The names of tree attribute variables (stored in the \code{trees@data}
#' slot). In addition to tree counts, the function will compute statistics for each of these variables.
#' Only numeric variables are accepted.
#' @param statFuns list. A named list of custom functions that are used to compute tree attribute
#' statistics. If none are provided, default statistics are mean, median, standard deviation,
#' minimum and maximum. Note that each element of the list should have a name that describes the
#' statistics generated by the function. See below for details on defining custom functions.
#'
#' @return Tree count and, if any \code{variables} are supplied, tree attribute statistics. If no
#' \code{areas} or \code{grid} is supplied, the tree count and statistics are computed for the entire
#' \code{trees} dataset, and returned as a 'data.frame' object. If \code{areas} are defined, an
#' identical \link[sp:SpatialPolygons]{SpatialPolygonsDataFrame} will be returned, with all computed statistics appended
#' to the object's \code{@@data} slot. If a \code{grid} is defined, tree count will be returned as a RasterLayer,
#' with cell values equal to the number of trees in each cell. If a \code{grid} and \code{variables} are defined,
#' a RasterBrick (see \link[raster]{brick}) will be returned instead, with tree count and attribute statistics
#' stored as stacked layers.
#'
#' @examples
#' # Load sample data
#' library(ForestTools)
#' library(sp)
#' data("kootenayTrees", "kootenayBlocks", "kootenayCrowns")
#'
#' # Get total tree count
#' SpatialStatistics(kootenayTrees)
#'
#' # Get total tree count, tree height and crown area statistics
#' SpatialStatistics(kootenayCrowns, variables = c("height", "crownArea"))
#'
#' # Get tree count, height statistics for specific areas of interest
#' areaStats <- SpatialStatistics(kootenayTrees, areas = kootenayBlocks, variables = "height")
#'
#' # Plot according to tree count
#' plot(areaStats, col = heat.colors(3)[order(areaStats$TreeCount)])
#'
#' # Get tree count and height statistics for a 20 x 20 m spatial grid
#' gridStats <- SpatialStatistics(kootenayTrees, grid = 20, variables = "height")
#'
#' # Plot gridded tree count and statistics
#' plot(gridStats$TreeCount)
#' plot(gridStats$heightMax)
#'
#' @seealso \code{\link{vwf}} \code{\link{SegmentCrowns}}
#' @importFrom stats median sd
#' @export

SpatialStatistics <- function(trees, areas = NULL, grid = NULL, variables = NULL, statFuns = NULL){

  ### GATEKEEPER

    if(!class(trees) %in% c("SpatialPointsDataFrame", "SpatialPolygonsDataFrame")) stop("Invalid input: \'trees\' must be a SpatialPointsDataFrame or SpatialPolygonsDataFrame")
    if(!is.null(areas) && !class(areas) %in% c("SpatialPolygonsDataFrame")) stop("Invalid input: \'areas\' must be a SpatialPolygonsDataframe object")
    if(!is.null(variables) && any(!variables %in% names(trees))) stop("Invalid input: \'trees\' does not contain variables: \'", paste(variables[!variables %in% names(trees)], collapse = "\', \'"), "\'")
    if(!is.null(variables) && any(sapply(trees@data[,variables], class) != "numeric")) stop("Invalid input: variables \'",paste(variables[sapply(trees@data[,variables], class) != "numeric"], collapse = "\', \'") , "\' is/are non-numeric")
    if(!is.null(grid) && !class(grid) %in% c("RasterLayer", "numeric")) stop("Invalid input: \'grid\' must be a Raster object or a numeric value")
    if(!is.null(grid) & !is.null(areas)) stop("Cannot compute output for both \'areas\' and \'grid\'. Please define only one.")

  ### PRE-PROCESS: Set statistic functions

  # If no custom functions are defined, use default
  if(is.null(statFuns)){
    statFuns <- c(mean, median, sd, min, max)
    names(statFuns) <-  c("Mean", "Median", "SD", "Min", "Max")

  # If custom functions ARE defined...
  }else{

    # Check that input is a named list of functions
    if(any(!sapply(statFuns, class) %in% c("standardGeneric", "function"))) stop("Input for 'statFuns' must be a named list of functions")
    if(is.null(names(statFuns))) stop("List of functions for 'statFuns' must be named")

    # Check that all input functions are valid
    for(funNum in 1:length(statFuns)){

      # Try using 'na.rm' argument
      narm <- try(statFuns[[funNum]](c(1,2,3), na.rm = TRUE), silent = TRUE)
      if(class(narm) == "try-error") stop("The '", names(statFuns)[funNum], "' function's arguments should be: function(x, ...)")

      # Try function using various inputs
      testInputs <- list(SingleNumeric = 5.2,
                         MultipleNumeric = seq(-1, 2, by = 0.13),
                         ContainsNA = c(1,2,NA,3),
                         SingleNA = NA)
      testResults <- lapply(testInputs, function(testInput) try(statFuns[[funNum]](testInput), silent = TRUE))

      # Check for invalid inputs
      check <- c()
      check["Function returned an error"] <- "try-error" %in% sapply(testResults, class)
      check["Returned value was neither logical or numeric"] <- any(!sapply(testResults, class) %in% c("logical", "numeric", "integer"))
      check["Returned more than a single value"] <- any(sapply(testResults, length) != 1)

      if(any(check)) stop("The '", names(statFuns)[funNum], "' function cannot be used.\n",
                          "Reasons:\n", paste0(1:length(check[check]), ". ", names(check)[check], "\n"))
    }
  }

  ### PRE-PROCESS: Function for computing statistics

    treeStats <- function(trees){

      # Calculate tree count
      outStats <- length(trees)
      names(outStats) <- "TreeCount"

      # Compute variable statistics if required
      if(!is.null(variables)){
        outStats <- c(outStats, do.call(c, lapply(variables, function(variable){

          variableStats <- sapply(statFuns, function(statFun) statFun(trees[[variable]]))
          names(variableStats) <- paste0(variable, names(statFuns))

          return(variableStats)
        })))
      }

      return(outStats)
    }

  ### PROCESS: No areas are given

    if(is.null(areas) & is.null(grid)){

      outData <- data.frame(treeStats(trees))
      colnames(outData) <- "Value"

      return(outData)
    }

  ### PROCESS: Convert polygons to points

  if(class(trees) == "SpatialPolygonsDataFrame"){
    cent <- rgeos::gCentroid(trees, byid = TRUE)
    trees <- sp::SpatialPointsDataFrame(cent, trees@data)
  }

  ### PROCESS: Area is a set of polygons

  if(class(areas) == "SpatialPolygonsDataFrame"){

    # Extract row names of overlapping polygons for each tree
    areas.treenames <- lapply(sp::over(areas, trees, returnList = TRUE), row.names)

    # Compute statistics of each areea
    areas.data <- do.call(rbind, lapply(areas.treenames, function(area.treenames){

      # Check number of trees found in area
      if(length(area.treenames) > 0){

        # Extract trees within a given area and calculate stats
        areaStats <- treeStats(trees[area.treenames,])

      }else{

        # Return NA values if no trees were found within area
        areaStats <- rep(NA, length(variables) * length(statFuns) + 1)
        names(areaStats) <- c("TreeCount", apply(expand.grid(variables, names(statFuns)), 1, paste, collapse = ""))
      }

      return(areaStats)
    }))

    # Attach data to SpatialPolygonsDataFrame
    areas@data <- cbind(areas@data, areas.data)

    if(all(is.na(areas.data))) warning("No trees located within given areas")

    return(areas)
  }

  ### PROCESS: Grid is a numeric value

    if(class(grid) == "numeric"){

      # Use numeric value to create a gridded Raster object

      # Get extent of trees
      trees.ext <- raster::extent(trees)

      # Create new extent that completely overlaps all trees
      ras.ext.xmin <- trees.ext@xmin
      ras.ext.ymax <- trees.ext@ymax
      ras.ext.xmax <- APfun::AProunder(trees.ext@xmax, interval = grid, direction = "up", snap = ras.ext.xmin)
      ras.ext.ymin <- APfun::AProunder(trees.ext@ymin, interval = grid, direction = "down", snap = ras.ext.ymax)
      ras.ext <- raster::extent(ras.ext.xmin, ras.ext.xmax, ras.ext.ymin, ras.ext.ymax)

      # Create gridded raster
      grid <- raster::raster(ras.ext, res = c(grid, grid), vals = 0, crs = sp::proj4string(trees))
    }

  ### PROCESS: Grid is a raster

    if(class(grid) == "RasterLayer"){

        # Compute tree count
        treesCount <- trees
        treesCount@data <- data.frame(counter = rep(1, length(treesCount)))
        outRas <- raster::rasterize(treesCount, grid, field = "counter", fun = "count")
        names(outRas) <- "TreeCount"
        if(all(is.na(outRas[]))) warning("No trees located within given grid")


        if(!is.null(variables)){

          # Compute gridded statistics
          statRas <- raster::brick(lapply(statFuns, function(statFun){
            raster::rasterize(trees, grid, field = variables, fun = statFun)}))
          names(statRas) <- apply(expand.grid(variables, names(statFuns)), 1, paste, collapse = "")

          outRas <- raster::brick(outRas, statRas)
        }

        return(outRas)
    }
}


